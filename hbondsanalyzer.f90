program hbondsanalyzer

! created by Sam Hertig, sam.hertig@gmail.com

! To be used with VMD/NAMD and two proteins (molecules A and B) in a waterbox.

! This program analyzes the output files "i_salt_Hbd_????" generated by the script "hbonds.tcl" by A. Anishkin.
! (Should be used with an atomselection like "protein or within 5 of protein".)

! Usage: Compile with any FORTRAN compiler, e.g. type "gfortran hbondsanalyzer.f90". Run by typing "./a.out".

! 3 Output files are generated:

! #1: outputAwater.dat: matrix, x-axis: residues, y-axis: time
!     first row: residue number (mol A only)
!     entries: 0 for no hbond with water, 1 for contact with backbone, 2 for contact with sidechain 
!                                                                      (or: sidechain and backbone)    

! #2: outputproteinAA.dat: matrix, x-axis: residue pairs, y-axis: time
!     first row: residue number of 1st partner (mol A)
!     second row: residue number of 2nd partner (mol A)
!     third row: total frames of present intRAmolecular hbonds of this particular pair (mol A only)
!     entries: 0 for no hbond, 1 for backbone-backbone, 2 for sidechain-backbone or sidechain-sidechain

! #3: outputproteinAB.dat: matrix, x-axis: residue pairs, y-axis: time
!     first row: residue number of 1st partner (mol A)
!     second row: residue number of 2nd partner (mol B)
!     third row: total frames of present intERmolecular hbonds of this particular pair (between mols A and B)
!     entries: 0 for no hbond, 1 for backbone-backbone, 2 for sidechain-backbone or sidechain-sidechain

! Specify your system:

implicit none

integer, parameter :: n=699           ! enter number of frames
integer, parameter :: firstresA=17    ! enter number of first residue of mol A
integer, parameter :: lastresA=109    ! enter number of last residue of mol A
integer, parameter :: firstresB=13    ! enter number of first residue of mol B
integer, parameter :: lastresB=36     ! enter number of last residue  of mol B

! Check your system's names of chains and water groups. Specify them in the main loop below.

! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

! define variables:

integer :: i=0, j=0, k=0, donnumber=0, accnumber=0, stat, maxprotprotintac=0, totres=0
integer :: AAintac=0, ABintac=0
integer :: moeller=0, somenumberone=0, somenumbertwo=0, sumhbonds=0, totresA=0, totresB=0
character(len=19) :: filename
character(len=3) :: donname, donchain, accname, accchain
integer, dimension(0:n,firstresA:lastresA) :: matrixone=0
integer, dimension(0:n+2,1:((lastresA-firstresA+lastresB-firstresB+2)* &
& ((lastresA-firstresA+lastresB-firstresB+2)-1))/2) :: matrixtwo=0
integer, dimension(:,:), allocatable :: matrixthree
integer, dimension(:,:), allocatable :: matrixfour

! matrixone: used for protein A and water
! matrixtwo: used for protein A and protein A or B (not written as an output file)
! matrixone: used for protein A and protein A
! matrixone: used for protein A and protein B

! preliminary calculations:

totresA=lastresA-firstresA+1
totresB=lastresB-firstresB+1
totres=totresA+totresB
maxprotprotintac=(totres*(totres-1))/2

! label first columns of output matrices:

k=0

do i=firstresA, lastresA
  matrixone(0,i)=i
end do

do j=totres-1, 1, -1
  do i=1, j
    k=k+1
    matrixtwo(0,k)=firstresA+totres-1-j
    matrixtwo(1,k)=firstresA+i+totres-1-j
  end do
end do

! testing/writing:

write(*,*) "# of frames:"
write(*,*) n
write(*,*) "# of residues of mol A:"
write(*,*) totresA
write(*,*) "# of residues of mol B:"
write(*,*) totresB
write(*,*) "# of total residues:"
write(*,*) totres
write(*,*) "# of possible hbond pairs:"
write(*,*) maxprotprotintac

! open files:

open(unit=2,file='outputAwaterV3.dat')
!open(unit=3,file='outputprotein2.dat')
open(unit=4,file='outputproteinAAV3.dat')
open(unit=5,file='outputproteinABV3.dat')

! main analysis loop:

write(*,*) "Looping over timesteps..."

do i = 0,n-1

  write(filename,"('i_salt_Hbd_',i4.4,'.txt')") i+1 !changed from i to i+1
  open(unit=1,file=filename)

  readingloop: do 

    read(1,*,iostat=stat) donname, donnumber, donchain, accname, accnumber, accchain

    !write(*,*) donname, donnumber, donchain, accname, accnumber, accchain

    if (stat/=0) exit

    ! compute watermatrix:

    if (donchain=="WT1" .and. accchain=="P1") then
      if(accname=="CA" .or. accname=="C" .or. accname=="O" .or. accname=="N") then
        if(matrixone(i+1,accnumber)==0) then
          matrixone(i+1,accnumber)=1
        end if
      else
        matrixone(i+1,accnumber)=2
      end if
    else if (accchain=="WT1" .and. donchain=="P1") then
      if(donname=="CA" .or. donname=="C" .or. donname=="O" .or. donname=="N") then
        if(matrixone(i+1,donnumber)==0) then
          matrixone(i+1,donnumber)=1
        end if
      else
        matrixone(i+1,donnumber)=2
      end if
    else if (donchain=="WT2" .and. accchain=="P1") then 
      if(accname=="CA" .or. accname=="C" .or. accname=="O" .or. accname=="N") then
        if(matrixone(i+1,accnumber)==0) then
          matrixone(i+1,accnumber)=1
        end if
      else
        matrixone(i+1,accnumber)=2
      end if
    else if (accchain=="WT2" .and. donchain=="P1") then
      if(donname=="CA" .or. donname=="C" .or. donname=="O" .or. donname=="N") then
        if(matrixone(i+1,donnumber)==0) then
          matrixone(i+1,donnumber)=1
        end if
      else
        matrixone(i+1,donnumber)=2
      end if
    else if (donchain=="WT3" .and. accchain=="P1") then 
      if(accname=="CA" .or. accname=="C" .or. accname=="O" .or. accname=="N") then
        if(matrixone(i+1,accnumber)==0) then
          matrixone(i+1,accnumber)=1
        end if
      else
        matrixone(i+1,accnumber)=2
      end if
    else if (accchain=="WT3" .and. donchain=="P1") then
      if(donname=="CA" .or. donname=="C" .or. donname=="O" .or. donname=="N") then
        if(matrixone(i+1,donnumber)==0) then
          matrixone(i+1,donnumber)=1
        end if
      else
        matrixone(i+1,donnumber)=2
      end if

    ! compute proteinmatrix:

    else if (donchain=="P1" .and. accchain=="P1") then

      if(donnumber/=accnumber)then

        !make sure don<acc, otherwise exchange
        if(donnumber>accnumber)then
          !switch acc and don:
          somenumberone=accnumber
          somenumbertwo=donnumber
          donnumber=somenumberone
          accnumber=somenumbertwo
        end if

        !compute column number (thanks Jens)
        moeller=(donnumber*(lastresA+totresB))-(firstresA*(lastresA+totresB))+ &
        & accnumber-((0.5)*(donnumber**2+firstresA+donnumber-firstresA**2))

        !write entry in matrixtwo: 
        !matrixtwo(i+3,moeller)=1 
        if(donname=="CA" .or. donname=="C" .or. donname=="O" .or. donname=="N") then
          if(accname=="CA" .or. accname=="C" .or. accname=="O" .or. accname=="N") then
            matrixtwo(i+3,moeller)=1 !BB-BB
          else
            matrixtwo(i+3,moeller)=2 !SC-BB
          end if
        else
          matrixtwo(i+3,moeller)=2 !BB-SC or SC-SC
        end if

        !mark column as active:
        matrixtwo(2,moeller)=7 !7 stands for intRAmolecular interaction
        
      end if

    ! compute interactions between molecule A and B:

    else if (donchain=="P1" .and. accchain=="P2") then

      !don<acc so everything is ok, however accnumber needs to be redefined:
      accnumber=accnumber+lastresA-firstresB+1

      !compute column number (thanks Jens)
      moeller=(donnumber*(lastresA+totresB))-(firstresA*(lastresA+totresB))+ &
      & accnumber-((0.5)*(donnumber**2+firstresA+donnumber-firstresA**2))

      !write entry in matrixtwo: 
      !matrixtwo(i+3,moeller)=1
        if(donname=="CA" .or. donname=="C" .or. donname=="O" .or. donname=="N") then
          if(accname=="CA" .or. accname=="C" .or. accname=="O" .or. accname=="N") then
            matrixtwo(i+3,moeller)=1 !BB-BB
          else
            matrixtwo(i+3,moeller)=2 !SC-BB
          end if
        else
          matrixtwo(i+3,moeller)=2 !BB-SC or SC-SC
        end if


      !mark column as active:
      matrixtwo(2,moeller)=8 !8 stands for intERmolecular interaction

    else if (donchain=="P2" .and. accchain=="P1") then
      
      !in this case switch donnumber and accnumber to ensure that don<acc
      somenumberone=accnumber
      somenumbertwo=donnumber
      donnumber=somenumberone
      accnumber=somenumbertwo

      !now don<acc, however accnumber needs to be redefined:
      accnumber=accnumber+lastresA-firstresB+1

      !compute column number (thanks Jens)
      moeller=(donnumber*(lastresA+totresB))-(firstresA*(lastresA+totresB))+ &
      & accnumber-((0.5)*(donnumber**2+firstresA+donnumber-firstresA**2))

      !write entry in matrixtwo: 
      !matrixtwo(i+3,moeller)=1
        if(donname=="CA" .or. donname=="C" .or. donname=="O" .or. donname=="N") then
          if(accname=="CA" .or. accname=="C" .or. accname=="O" .or. accname=="N") then
            matrixtwo(i+3,moeller)=1 !BB-BB
          else
            matrixtwo(i+3,moeller)=2 !SC-BB
          end if
        else
          matrixtwo(i+3,moeller)=2 !BB-SC or SC-SC
        end if

      !mark column as active:
      matrixtwo(2,moeller)=8 !8 stands for intERmolecular interaction

    end if 

  end do readingloop

  close(1)

end do

write(*,*) "Preparing output and writing data..."

! truncate proteinmatrix:

!evaluate number of active interactions
do i=1,maxprotprotintac
  if(matrixtwo(2,i)==7)then
    AAintac=AAintac+1
  else if(matrixtwo(2,i)==8)then
    ABintac=ABintac+1
  end if
end do

! testing/writing:
write(*,*) "# of intRAmolecular hbond pairs:"
write(*,*) AAintac
write(*,*) "# of intERmolecular hbond pairs:"
write(*,*) ABintac

!create truncated empty matrix for intRAmolecular interactions:
allocate(matrixthree(0:n+2,1:AAintac))
matrixthree=0

!create truncated empty matrix for intERmolecular interactions:
allocate(matrixfour(0:n+2,1:ABintac))
matrixfour=0

!transfer columns from matrixtwo to matrixthree:

k=0
do i=1,maxprotprotintac  
  if(matrixtwo(2,i)==7)then
    k=k+1
    sumhbonds=0
    do j=0,n+2
      matrixthree(j,k)=matrixtwo(j,i)
      if(j>2 .and. matrixthree(j,k)/=0)then
        sumhbonds=sumhbonds+1
      end if
    end do
    matrixthree(2,k)=sumhbonds
  end if
end do

!test:
if(k/=AAintac)then
  write(*,*) "error1"
end if

!transfer columns from matrixtwo to matrixfour:

k=0
do i=1,maxprotprotintac  
  if(matrixtwo(2,i)==8)then
    k=k+1
    sumhbonds=0
    do j=0,n+2
      matrixfour(j,k)=matrixtwo(j,i)
      if(j>2 .and. matrixfour(j,k)/=0)then
        sumhbonds=sumhbonds+1
      end if
    end do
    matrixfour(2,k)=sumhbonds
  end if
end do

!test:
if(k/=ABintac)then
  write(*,*) "error2"
end if

! write watermatrix:

do j=0,n
  do i=firstresA,lastresA
    if(i==lastresA)then
      write(2,777) matrixone(j,i)
    else
      write(2,777,advance='no') matrixone(j,i)
    end if
  end do
end do

! write proteinmatrix:

!do j=0,n+2
  !do i=1,maxprotprotintac
    !if(i==maxprotprotintac)then
      !write(3,777) matrixtwo(j,i)
    !else
      !write(3,777,advance='no') matrixtwo(j,i)
    !end if
  !end do
!end do

! write proteinmatrix for intRAmolecular hbonds:

do j=0,n+2
  do i=1,AAintac
    if(i==AAintac)then
      write(4,777) matrixthree(j,i)
    else
      write(4,777,advance='no') matrixthree(j,i)
    end if
  end do
end do

! write proteinmatrix for intERmolecular hbonds:

do j=0,n+2
  do i=1,ABintac
    if(i==ABintac)then
      if(j==1)then
        !revert numbering of mol B
        matrixfour(j,i)=matrixfour(j,i)-lastresA+firstresB-1
      end if
      write(5,777) matrixfour(j,i)
    else
      if(j==1)then
        !revert numbering of mol B
        matrixfour(j,i)=matrixfour(j,i)-lastresA+firstresB-1
      end if
      write(5,777,advance='no') matrixfour(j,i)
    end if
  end do
end do

777 FORMAT (I7)

close(2)
!close(3)
close(4)
close(5)

write(*,*) "Finished."

end program hbondsanalyzer
